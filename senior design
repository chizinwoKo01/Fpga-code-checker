import re
import pyverilog
from pyverilog.vparser.parser import parse
from pyverilog import *


def correct_code(text, errorlist):
    corrected_code = text  # Start with the original code
    all_errors = []        # This collects all correction messages

    print(f"Initial code:\n{corrected_code}\n")
    for error in errorlist:
        print(f"Error in list: '{error}'")

    # Start processing from second element, assuming first is a label like 'failed checks list:'
    for error_message in errorlist[1:]:
        error_message = error_message.strip()
        print(f"Current error: {error_message}")

        if error_message == 'extract_module_names':
            print("Fixing invalid module names...")
            corrected_code = fix_invalid_module_names(corrected_code, all_errors)

        elif error_message == 'semicolon_placement':
            print("Fixing semicolon placement errors...")
            corrected_code = fix_missing_semicolons(corrected_code, all_errors)

        elif error_message == 'check_variable_names':
            print("Fixing invalid variable names...")
            corrected_code = fix_invalid_variable_names(corrected_code, all_errors)

        elif error_message == 'check_unclosed_brackets':
            print("Fixing unclosed brackets...")
            corrected_code = fix_unclosed_brackets(corrected_code, all_errors)

        elif error_message == 'check_always_sensitivity_list':
            print("Fixing empty always sensitivity lists...")
            corrected_code = fix_empty_sensitivity_lists(corrected_code, all_errors)

    return corrected_code, all_errors

def fix_missing_semicolons(text, all_errors):
    """
    Fix missing semicolons in Verilog code.
    Appends a semicolon to lines that appear to be statements but are missing a semicolon,
    excluding control structures, comments, and preprocessor directives.
    Logs each fix to all_errors.
    """
    lines = text.splitlines()
    corrected_lines = []

    keywords_to_exclude = ('begin', 'end', 'always', 'if', 'else', 'for', 'while', 'repeat', 'case', 'function', 'task')
    preprocessor_directives = ('`define', '`ifdef', '`endif', '`include')

    for line_number, line in enumerate(lines, 1):
        stripped_line = line.strip()

        # Preserve preprocessor directives and comments
        if (not stripped_line or 
            stripped_line.startswith(("//", "/*", "*/")) or 
            stripped_line.startswith(preprocessor_directives)):
            corrected_lines.append(line)
            continue

        # Ensure it's not a control structure
        if (not stripped_line.endswith(";") and 
            not stripped_line.startswith(keywords_to_exclude)):

            # Avoid adding semicolons to control structures like "if (...)"
            if not re.match(r".*\b(if|for|while|repeat|case)\b\s*\(.*\)", stripped_line):
                new_line = line.rstrip() + ";"
                corrected_lines.append(new_line)
                all_errors.append(f"Missing semicolon fixed on line {line_number}: '{stripped_line}'")
                continue

        corrected_lines.append(line)  # Leave line unchanged if correct

    return "\n".join(corrected_lines)


def fix_invalid_variable_names(text, all_errors):
    """
    Fix invalid variable declarations, such as:
    - Variables listed in the sensitivity list but not declared in the module.
    - Variables declared but not listed in the sensitivity list.

    Adds suggestions and warnings to all_errors.
    """
    lines = text.splitlines()
    corrected_lines = []

    # Pattern to match 'input', 'output', 'reg', 'wire' declarations
    module_var_pattern = r'\b(input|output)\s+(wire|reg\s+)?(\[\s*\d+\s*[:]\s*\d+\s*\]\s*)?([a-zA-Z_][a-zA-Z0-9_]*(?:\s*,\s*[a-zA-Z_][a-zA-Z0-9_]*\s*)*)\s*;'
    
    # Pattern to match the module sensitivity list
    sens_list_pattern = r'module\s+[^\s(]+?\s*\((.*?)\)\s*;'
    
    modvarslist = []  # List to store module variable groups
    sensvarslist = []  # List to store sensitivity list variables

    # Extract module port declarations (inputs, outputs, etc.)
    modvars = re.findall(module_var_pattern, text)
    for var in modvars:
        var_names = var[-1].split(',')
        if var[0].strip() != 'wire':
            modvarslist.append(var_names)
    
    flattened_modvarslist = [var.strip() for sublist in modvarslist for var in sublist]

    # Extract sensitivity list variables from the module declaration
    sensvars = re.findall(sens_list_pattern, text)
    if sensvars:
        sensvarslist = [var.strip() for var in sensvars[0].split(',')]

    # Identify variable mismatches
    missing_module_vars = [var for var in sensvarslist if var not in flattened_modvarslist]
    missing_sens_vars = [var for var in flattened_modvarslist if var not in sensvarslist]

    # Add messages to all_errors
    if missing_module_vars:
        all_errors.append(
            "The following variable(s) were in the module port list but not declared inside the module: " +
            ", ".join(sorted(set(sensvarslist).symmetric_difference(set(flattened_modvarslist)))) +
            ". Please declare them using input/output/reg."
        )
    elif missing_sens_vars:
        all_errors.append(
            "Module port list is missing the following declared variable(s): " +
            ", ".join(missing_sens_vars) +
            ". All declared variables should appear in the module port list."
        )

    # Reassemble the original code (no changes yet beyond warnings)
    for line in lines:
        corrected_lines.append(line)
        
    corrected_code = "\n".join(corrected_lines)
    return corrected_code


def fix_unclosed_brackets(text, all_errors):
    """
    Checks for unclosed or unmatched brackets and fixes them by inserting the correct ones.
    Appends fix info to the shared all_errors list.
    """
    stack = []
    corrected_code = text

    for i, char in enumerate(text):
        if char in "([{":
            stack.append((char, i))  # Opening bracket
        elif char in ")]}":
            if stack and ((char == ')' and stack[-1][0] == '(') or
                          (char == ']' and stack[-1][0] == '[') or
                          (char == '}' and stack[-1][0] == '{')):
                stack.pop()  # Proper match
            else:
                if stack:
                    expected_bracket = get_matching_bracket(stack[-1][0])
                    corrected_code = corrected_code[:i] + expected_bracket + corrected_code[i:]
                    all_errors.append(
                        f"Unmatched closing bracket '{char}' at position {i}. Inserted '{expected_bracket}'."
                    )
                    stack.pop()
                    break  # Fix one mismatch at a time
                else:
                    all_errors.append(
                        f"Unmatched closing bracket '{char}' at position {i} with no corresponding opening bracket."
                    )

    if stack:
        for char, index in stack:
            appended_bracket = get_matching_bracket(char)
            corrected_code += appended_bracket
            all_errors.append(
                f"Unclosed opening bracket '{char}' at position {index}. Appended '{appended_bracket}'."
            )

    return corrected_code


def get_matching_bracket(open_bracket):
    """ Helper function to return the matching closing bracket """
    matching_brackets = {'(': ')', '[': ']', '{': '}'}
    return matching_brackets.get(open_bracket, '')


def fix_empty_sensitivity_lists(text, all_errors):
    """
    Fix empty sensitivity lists in 'always' blocks by inserting a module variable.
    Appends any corrections or info messages directly to the shared all_errors list.
    """
    # Pattern to match the module declaration (input/output/reg variables)
    module_pattern = r'\b(input|output|reg)\s+(wire|reg)?\s*(\[\s*\d*\s*[:]\s*\d*\s*\])?\s*([a-zA-Z_][a-zA-Z0-9_]*)'
    always_pattern = r'\balways@\(\s*\)\s*'

    corrected_code = text

    # Find all module port declarations (inputs, outputs)
    module_ports = re.findall(module_pattern, text)
    module_vars = [x[-1] for x in module_ports]

    # Find all always blocks with empty sensitivity lists
    matches = re.findall(always_pattern, text)

    if matches:
        for _ in matches:
            if module_vars:
                replacement = f"always @({module_vars[-1]})"
                corrected_code = corrected_code.replace("always@()", replacement, 1)
                all_errors.append(f"Empty always sensitivity list found; replaced with '{replacement}'.")
            else:
                all_errors.append("Empty always sensitivity list found, but no module variables were declared for replacement.")
    else:
        all_errors.append("No empty always sensitivity lists found.")

    return corrected_code


def fix_invalid_module_names(text, all_errors):
    """
    Fixes invalid module names and appends messages to the all_errors list.
    """
    corrected_code = text
    module_pattern = r'\bmodule\s+([^\s\(\)]+)\s*(?=\()'
    module_names = re.findall(module_pattern, text)
    
    for name in module_names:
        if name[0].isdigit() or re.search(r'[^a-zA-Z0-9_]', name):
            corrected_name = re.sub(r'[^a-zA-Z0-9_]', '', name)
            corrected_name = corrected_name.lstrip('0123456789')
            corrected_code = corrected_code.replace(name, corrected_name)
            all_errors.append(f"Replaced module name '{name}' with '{corrected_name}'.")

    if not module_names:
        all_errors.append("No module name found.")
    elif not any(name[0].isdigit() or re.search(r'[^a-zA-Z0-9_]', name) for name in module_names):
        all_errors.append("No invalid module names found.")

    return corrected_code


def semicolon_placement(text):
    """
    Function to check if the placement of semicolons in Verilog code is valid.
    It checks if a semicolon appears in valid places and warns about incorrect usage.
    """
    lines = text.splitlines()  # Split the text into lines
    errors = []  # List to hold error messages
    
    inside_module = False  # Flag to track if we're inside a module declaration
    
    for line_num, line in enumerate(lines, 1):
        # Remove comments from the line (everything after '//')
        line = re.sub(r'//.*', '', line).strip()
        
        # Ignore empty lines or lines that are just comments
        if not line:
            continue
        
        # Case 1: Check if 'module' declaration is multi-line and has a semicolon after ')'
        if line.startswith("module"):
            inside_module = True  # We are inside a module declaration
            if line.endswith("endmodule"): # check if the code is all in one line (module and endmodule are on the same line in this case.)
                continue
            elif ")" in line:  # If we find the closing parenthesis on the same line
                # Check if the next character after ')' is a semicolon
                if not line.strip().endswith(";"):
                    errors.append(f"Error: 'module' declaration should end with a semicolon on line {line_num}: {line}")
                inside_module = False  # No longer inside the module declaration
            else:
                # The module declaration is split across multiple lines, so continue
                continue

        # If we are inside a module and the line ends with ')', check for a semicolon
        if inside_module:
            if ")" in line:  # This line contains the closing parenthesis of the module portlist
                # Check if the next character after ')' is a semicolon
                if not line.strip().endswith(";"):
                    errors.append(f"Error: 'module' declaration should end with a semicolon on line {line_num}: {line}")
                inside_module = False  # No longer inside the module declaration
        
        # Case 2: Check if 'begin' or 'end' have semicolons (they should not)
        elif re.search(r'\b(begin|end)\b', line) and line.endswith(";"):
            errors.append(f"Error: Semicolon placed after '{line}' on line {line_num}. 'begin' and 'end' should not end with semicolons.")
        
        # Case 3: Check if the line contains a statement but does not end with a semicolon
        elif re.search(r'(input|output|reg|wire|assign|always|if|for|while)', line) and not line.endswith(";"):
            # Exclude lines that are 'always' or 'if' statements, they don't need semicolons
            if line.startswith("always") or line.startswith("if"):
                continue  # Skip this line, as 'always' and 'if' don't require a semicolon after them
            if not line.startswith("module") and not line.startswith("endmodule"):
                errors.append(f"Error: Missing semicolon at the end of statement on line {line_num}: {line}")

        # Case 4: Check if the line is an assignment statement and ends with a semicolon
        elif re.search(r'\b(assign|=)\b', line) and not line.endswith(";"):
            errors.append(f"Error: Missing semicolon at the end of assignment statement on line {line_num}: {line}")
        
    # Return the list of errors found
    return errors



def check_unclosed_brackets(text):
    stack = []
    pairs = {'(': ')', '[': ']', '{': '}'}
    errors = []  # List to store error messages
    
    for line_num, line in enumerate(text.splitlines(), 1):
        for char_num, char in enumerate(line, 1):
            if char in pairs.keys():
                stack.append((char, line_num, char_num))  # Store the opening bracket with its position
            elif char in pairs.values():
                if not stack or pairs[stack[-1][0]] != char:
                    errors.append(f"Error: Unmatched closing bracket '{char}' on line {line_num}, position {char_num}.")
                else:
                    stack.pop()  # Pop the matched opening bracket
    
    # If there are still unclosed opening brackets in the stack, report them
    while stack:
        opening_bracket, line_num, char_num = stack.pop()
        closing_bracket = pairs[opening_bracket]
        errors.append(f"Error: Unclosed opening bracket '{opening_bracket}' on line {line_num}, position {char_num}.")
    
    # Return the errors list
    return errors  # Return the list of errors found

def check_variable_names(text):
    """
    Function to check the validity of all variable names in the Verilog code.
    It looks for 'input', 'output', 'reg', and 'wire' declarations and checks the variable names.
    """
    # Regular expression to match 'input wire', 'output wire', 'input', 'output', 'reg' declarations
    pattern = r'\b(input|output)\s+(wire|reg)?\s*(\[\s*\d+\s*[:]\s*\d+\s*\]\s*)?([a-zA-Z_][a-zA-Z0-9_]*(?:\s*,\s*[a-zA-Z_][a-zA-Z0-9_]*\s*)*)\s*'

    reserved_keywords = [
        "module", "always", "initial", "assign", "if", "else", "for", "while", 
        "case", "end", "parameter", "input", "output", "reg", "wire"
    ]
    
    pattern2 = r'module\s+[^\s(]+?\s*\((.*?)\)\s*;'
    matches2 = re.findall(pattern2, text, flags = re.DOTALL)
    port_names = []
    for x in matches2:
        # Split the port list into individual ports
        ports = [port.strip() for port in x.split(',')]
        port_names.extend(ports)

    # Find all matches for the pattern
    matches = re.findall(pattern, text)
    
    invalid_names = []
    var_names = []
    errors = []  # List to store error messages

    for match in matches:
        # match[0] is the variable type and match[2] is the variable name
        var_type = match[0]
        variable_names = match[-1].split(',')  # Split multiple variables by commas
        variable_names = [var.strip() for var in variable_names]  # Strip extra spaces
        for variable_name in variable_names:
            var_names.append((var_type, variable_name))  # Store both type and name

    undeclared_module_vars = [] # List for variables in sens list but not inside module
    undeclared_sens_vars = [] # List for variables in module but not inside sens list
    for var_type, variable_name in var_names:
        line_num = find_line_number(text, variable_name)

        # Check if the variable name is a reserved keyword
        if variable_name in reserved_keywords:
            errors.append(f"Error: Variable name '{variable_name}' at line {line_num} cannot be a reserved keyword in Verilog.")
            invalid_names.append(variable_name)
        
        # Validate the variable name
        elif variable_name[0].isdigit():
            errors.append(f"Error: Variable name '{variable_name}' at line {line_num} cannot start with a digit.")
            invalid_names.append(variable_name)
        
        # Check if the variable contains invalid characters (like @, $, %, etc.)
        elif re.search(r'[^a-zA-Z0-9_]', variable_name):
            errors.append(f"Error: Variable name '{variable_name}' at line {line_num} contains invalid characters.")
            invalid_names.append(variable_name)
        
        # Check if the variable is a valid name
        elif re.match(r'^[a-zA-Z_][a-zA9-9_]*$', variable_name):
            continue  # This is a valid name, so we move to the next check

    # Check if any undeclared variables are in the sensitivity list but not declared in the module
    for x in port_names:  # Port names are variables declared in the sensitivity list
        if x not in [var[1] for var in var_names]:  # Variable names declared in the actual module
            undeclared_module_vars.append(x)

    # Check if any undeclared variables are in the module but not in the sensitivity list
    for var_type, x in var_names:
        # Skip 'wire' types for undeclared_vars1 check
        if var_type == 'wire':
            continue  # Move to the next variable if the type is 'wire'
        if x not in port_names:
            undeclared_sens_vars.append(x)

    # If any undeclared variables are found, report them
    if undeclared_module_vars:
        for var in undeclared_module_vars:
            errors.append(f"Error: Variable {var} declared in sensitivity list but not declared within the module.")

    if undeclared_sens_vars:
        for var in undeclared_sens_vars:
            errors.append(f"Error: Variable {var} declared in module but not declared within the sensitivity list.")

    # If any invalid names are found, report them
    if invalid_names:
        errors.append(f"Invalid variable names: {', '.join(invalid_names)}")
    
    # Return the error list
    if errors:
        return errors
    else:
        return ["All variable names are valid."]


def find_line_number(text, target):
    """
    Function to find the line number of a target string in the Verilog code.
    Returns an error message if the target is not found in the text.
    """
    lines = text.splitlines()  # Split the text into lines
    for index, line in enumerate(lines, 1):  # Enumerate with line numbers starting from 1
        if target in line:  # Check if the target string is in the line
            return index  # Return the line number
    # If the target is not found, return an error message
    return f"Error: Target '{target}' not found in the code."

def check_always_sensitivity_list(text):
    """
    Function to check the always blocks for sensitivity lists containing ports.
    This function works before the AST is generated.
    """
    always_pattern = r'\balways@\(\s*\)\s*'  # Matches always block with empty sensitivity list
    always_blocks = list(re.finditer(always_pattern, text))  # Find all always blocks
    error_messages = []  # List to hold error messages

    if always_blocks:
        for match in always_blocks:
            # Get the line number where the 'always' block with empty sensitivity list is found
            line_num = find_line_number(text, match.group())
            error_messages.append(f"Warning: Empty sensitivity list in 'always' block at line {line_num}.")
    
    if error_messages:
        # Return all error messages
        for error in error_messages:
            print(error)
        return False
    else:
        print("All 'always' blocks have non-empty sensitivity lists.")
        return True
  
def extract_module_names(text):
    # Regular expression to match 'module' followed by a name with special characters, stopping before '('
    pattern = r'\bmodule\s+([^\s\(\)]+)\s*(?=\()'
    
    # Find all matches for the pattern
    module_names = re.findall(pattern, text)
    for x in module_names:
        res = find_line_number(text, x)
        if x[0].isdigit():
            print(f"Module name on line {res} cannot start with digit: {x}")
            return False
            break
        elif re.search(r'[^a-zA-Z0-9_]', x):
            print(f"Module name on line {res} cannot start with, contain, or end with a special character: {x}")
            return False
            break
    # Ensure the module name doesn't start or end with special characters
        elif not x[0].isalnum() or not x[-1].isalnum():
            return False
            break
        else:
            print(f"valid module name detected: {x}")
    return True
            
            
 
# Function to simulate the process of making the file
def make_file(text):
    filename = "makeFile.v"
    print(f"Running checks for input:\n{text}\n")

    functions = [
        extract_module_names,
        check_variable_names,
        semicolon_placement,
        check_unclosed_brackets,
        check_always_sensitivity_list
    ]

    passed = True
    passedlist = ["Passed checks list:"]
    failedlist = ["Failed checks list:"]
    all_errors = []

    for func in functions:
        print(f"Running check: {func.__name__}")
        result = func(text)

        if isinstance(result, bool):
            if result:
                passedlist.append(func.__name__)
                print("Check passed.\n")
            else:
                failedlist.append(func.__name__)
                all_errors.append(f"{func.__name__} failed.")
                passed = False
                print("Check failed.\n")

        elif isinstance(result, list):  # e.g. error messages returned directly
            if result:
                failedlist.append(func.__name__)
                all_errors.extend(result)
                passed = False
                print("Check failed with error messages.\n")
            else:
                passedlist.append(func.__name__)
                print("Check passed.\n")

        elif isinstance(result, tuple) and not result[0]:
            failedlist.append(func.__name__)
            all_errors.extend(result[1])
            passed = False
            print("Check failed with error messages.\n")

        else:
            print(f"Unexpected result format from {func.__name__}: {result}")

    # If all checks passed
    if passed:
        print(f"All checks passed: {' '.join(passedlist[1:])}")
        with open(filename, "w+") as file:
            file.write(text)
        parse_file(filename)
        return [], text

    # If some checks failed
    else:
        print(f"\n{' '.join(failedlist)}")
        if passedlist[1:]:
            print(f"Passed checks: {' '.join(passedlist[1:])}")

        # Print errors messages
        print("\nError messages from failed checks:")
        for error in all_errors:
            print(error)

        # Get corrected code and fixes
        corrected_code, corrections = correct_code(text, failedlist)

        print("\nErrors Found:")
        for fix in corrections:
            print(fix)

        print("\nCorrected Code:")
        print(corrected_code)

        return all_errors, corrected_code


# Function to parse the Verilog file and handle AST
def parse_file(filename):
    ast = None
    try:
        with open(filename, 'r') as f:
            #print("File content:")
            #print(f.read())
            print("Checks passed.")
            print("Parsing file...")
            ast, _ = parse([filename], debug=True)  # Ensure the file path is passed as a list
            print("Parsing successful.")
    except pyverilog.vparser.parser.ParseError as e:
        print(f"Verilog Parsing Error: {e}")
    except Exception as e:
        print(f"Unexpected error: {e}")

    # Proceed with AST processing only if parsing is successful
    if ast is not None:  # Ensure AST is valid before proceeding
        if hasattr(ast, 'description'):
            if hasattr(ast.description, 'children'):
                print("Processing children...")
                children = ast.description.children()  # Call the method to get the children
                check_code(children)
            else:
                print("No children attribute found in description.")
        else:
            print("AST doesn't have a description attribute.")
    else:
        print()
        print("AST is None, skipping further processing.")


# Function to check the parsed module details
def check_code(children):
    global module_details
    module_details = []
    for item in children:
        if isinstance(item, pyverilog.vparser.ast.ModuleDef):  # Check if it's a ModuleDef object
            find_ports(item)

def find_ports(item):
    try:
        module_info = {
            'name': item.name,
            'ports': []
        }
        # Check if the module has an empty portlist
        if not item.portlist.ports:  # No ports declared
            print(f"Error: Module '{item.name}' does not have any ports declared but is using ports.")
            module_info['ports'].append("No ports declared")
            return
            
        # Iterate through ports in the portlist
        for port in item.portlist.ports:
            if isinstance(port, pyverilog.vparser.ast.Ioport): # Check if port is an Ioport object
                if isinstance(port.first, pyverilog.vparser.ast.Input):
                    if isinstance(port.second, pyverilog.vparser.ast.Wire):
                        port_name = "Input " + "wire " + port.first.name
                        module_info['ports'].append(port_name)
                        continue
                    elif isinstance(port.second, pyverilog.vparser.ast.Reg):
                        port_name = "Input " + "register " + port.first.name
                        module_info['ports'].append(port_name)
                        continue
                    port_name = "Input " + port.first.name
                    module_info['ports'].append(port_name)
                elif isinstance(port.first, pyverilog.vparser.ast.Output):
                    if isinstance(port.second, pyverilog.vparser.ast.Wire):
                        port_name = "Output " + "wire " + port.first.name
                        module_info['ports'].append(port_name)
                        continue
                    elif isinstance(port.second, pyverilog.vparser.ast.Reg):
                        port_name = "Output " + "register " + port.first.name
                        module_info['ports'].append(port_name)
                        continue
                    port_name = "Output " + port.first.name
                    module_info['ports'].append(port_name)
            elif isinstance(port, pyverilog.vparser.ast.Port): # check if current port is general declared port(a port that is only declared in the module sens list with a letter and no direction (in or output)
                continue    
            else:
                print(f"Port {port} has no 'first' attribute value.")
        else:
            if hasattr(item, 'items'):
                find_instances(item, module_info)  # Check instances if any

    except AttributeError as e:
        print(f"Error while accessing ports for module {item.name}: {e}")


def find_instances(item, module_info):
    module_info['instances'] = []
    for instance in item.items:
        # Handling Assign statements (Blocking and Non-blocking)
        if isinstance(instance, pyverilog.vparser.ast.Assign):  # Check for assignment statements
            
            if hasattr(instance.right.var, 'cond'): ## this will account for conditional statements. ex: assign out = sel ? in[1] : in[0];
                lhs = instance.left.var
                true_val = str(instance.right.var.true_value.var) + str(f'[{instance.right.var.true_value.ptr}]' if instance.right.var.false_value.ptr else None)
                false_val = str(instance.right.var.false_value.var) + str(f'[{instance.right.var.false_value.ptr}]' if instance.right.var.false_value.ptr else None)
                rhs = instance.right.var.cond.name 
                instance_info = {'Assign statement': f'{lhs} = {true_val} if {rhs} is true, otherwise {lhs} = {false_val}'}
                module_info['instances'].append(instance_info)
            else:
                lhs = instance.left.var 
                rhs = instance.right.var
                instance_info = {
                    'Assign statement': f'{lhs} = {rhs}',  # Left-hand side and Right-hand side of the assignment
                    
                }
                module_info['instances'].append(instance_info)
        
        # Handling Always block
        elif isinstance(instance, pyverilog.vparser.ast.Always):
            senslist = instance.sens_list.list  # Sensitivity list
            portlist = ""
            for x in senslist: # .type returns if the sig if pos/neg edge, .sig returns the variable name
                if x.type == 'all':
                    portlist += 'any variable used in this block'
                elif x.type: # if senslist uses edge triggered sigs like pos/negedge
                    portlist += f"{x.type} {x.sig} "
                else: # if senslist only uses var names such as 'always @(a)'
                    portlist += f"{x.sig} "
            instance_info = {
                'Always senslist': portlist
            }
            module_info['instances'].append(instance_info)
            # Print for debugging
            # Ensure statement is a Block before accessing its statements
            if isinstance(instance.statement, pyverilog.vparser.ast.Block):
                # This ensures we're working with a Block type statement                
                # If the block contains statements, process them
                if hasattr(instance.statement, 'statements'):
                    for stmt in instance.statement.statements:
                        #print("Processing statement:", stmt)

                        # Handling BlockingSubstitution statements
                        if isinstance(stmt, pyverilog.vparser.ast.BlockingSubstitution):
                            print("BlockingSubstitution statement found")
                            astatement = f"{stmt.left.var} = {stmt.right.var}"  # Blocking assignment
                            instance_info = {
                                'Always statement': astatement
                            }
                            module_info['instances'].append(instance_info)
                        
                        # Handling NonblockingSubstitution statements
                        elif isinstance(stmt, pyverilog.vparser.ast.NonblockingSubstitution):
                            print("NonblockingSubstitution statement found")
                            if hasattr(stmt.right.var, 'left'):
                                astatement = f"{stmt.left.var} <= {stmt.right.var.left} {type(stmt.right.var).__name__} {stmt.right.var.right}"
                            #print((stmt.right.var.left))
                            #print(stmt.right.var.right)
                            else:
                                astatement = f"{stmt.left.var} <= {stmt.right.var}"  # Non-blocking assignment
                            instance_info = {
                                'Always statement': astatement
                            }
                            module_info['instances'].append(instance_info)
                        
                        # Handling IfStatement (conditional statements)
                        elif isinstance(stmt, pyverilog.vparser.ast.IfStatement):
                            if hasattr(stmt.cond, 'left'):
                                # print((stmt.cond.left))
                                # print(type(stmt.cond).__name__)
                                # print((stmt.cond.right))
                                cond = f'{str(stmt.cond.left)} { type(stmt.cond).__name__} { str(stmt.cond.right)}'
                                # print(f'If {cond}')
                                # print(dir(stmt))
                                # print(dir(stmt.true_statement))
                                # print((stmt.true_statement.right.var.ptr))
                                # print((stmt.true_statement.right.var.var))
                                
                                tst = f'{stmt.true_statement.left.var} =' + f' {stmt.true_statement.right.var.var}' + f'[{stmt.true_statement.right.var.ptr}]' if stmt.true_statement.right.var.ptr else ''
                                fst = f'{stmt.false_statement.left.var} =' + f' {stmt.false_statement.right.var.var}' + f'[{stmt.false_statement.right.var.ptr}]' if stmt.false_statement.right.var.ptr else ''
                                ifstatement = f'If {cond}, then {tst}. Else {fst}'
                                instance_info = {
                                        'If statement': ifstatement
                                         }
                                module_info['instances'].append(instance_info)
                                break
                            if not hasattr(stmt.cond, 'left'):
                                if isinstance(stmt.true_statement, pyverilog.vparser.ast.Block):
                                    tstatement = ''
                                    for x in stmt.true_statement.statements:
                                        if isinstance(x, pyverilog.vparser.ast.NonblockingSubstitution):
                                            tstatement += f'{x.left.var} = {x.right.var} '
                                    if hasattr(stmt.false_statement, 'statements'):
                                        for x in stmt.false_statement.statements:
                                            if isinstance(x, pyverilog.vparser.ast.NonblockingSubstitution):
                                                fstatement = f'{x.left.var} = {x.right.var}'
                                            # This writes to module info if both T/F statements are present and it is a Block object
                                                ifstatement = f"if {stmt.cond}, then {tstatement}. Else, {fstatement}. "
                                                instance_info = {
                                        'If statement': ifstatement
                                         }
                                                module_info['instances'].append(instance_info)
                                                break
                                    elif not hasattr(stmt.false_statement, 'statements'):
                                    #executes when block object is found but there is no false statement
                                        ifstatement = f"if {stmt.cond}, then {tstatement}. No else statement found. "
                                        instance_info = {
                                        'If statement': ifstatement
                                         }
                                        module_info['instances'].append(instance_info)
                                        break
                                        
                                else: # executes when no block object is found
                                    if hasattr(stmt.false_statement, 'left'): # executes if there is an else statement (false statement)
                                        ifstatement = f'if {stmt.cond}, then {stmt.true_statement.left.var} = {stmt.true_statement.right.var}. Else, {stmt.false_statement.left.var} = {stmt.false_statement.right.var}'
                                        instance_info = {
                                        'If statement': ifstatement
                                         }
                                        module_info['instances'].append(instance_info)
                                        break
                                    elif not hasattr(stmt.false_statement, 'left'): # executes if there isn't a false statement
                                        ifstatement = f'if {stmt.cond}, then {stmt.true_statement.left.var} = {stmt.true_statement.right.var}. No else statement found.'
                                        instance_info = {
                                         'If statement': ifstatement
                                          }
                                        module_info['instances'].append(instance_info)
                                        break
                        elif isinstance(stmt, pyverilog.vparser.ast.CaseStatement):
                            x = stmt.comp.name # this is the variable we are checking for our case statements
                            cst2 = ''
                            for x in stmt.caselist: # iterate through case statements
                                # cond[0] holds the statement condition, statement.left/.right contain the variables used. 
                                cst = f'If {stmt.comp.name} is {x.cond[0]}, then {x.statement.left.var} = {x.statement.right.var.var}' + f'[{x.statement.right.var.ptr}]' if x.statement.right.var.ptr else '' 
                                cst = cst + '. '
                                cst2 = cst2 + (cst)
                            instance_info = {'Case Statement': cst2}
                            module_info['instances'].append(instance_info)
                        else:
                            print(f"always statement found is not a blking/nonblking/if statement ")
                else:
                    print("No statements found in this block")
            else:
                print("instance.statement is not a Block object")

        # Handling Initial block statements
        elif isinstance(instance, pyverilog.vparser.ast.Initial):
            initstatement1 = ""
            for x in instance.statement.statements:
                if isinstance(x, pyverilog.vparser.ast.NonblockingSubstitution):
                    initstatement = f"{x.left.var} <= {x.right.var} "
                    initstatement1 += initstatement
            instance_info = {
                'Variables initialized': initstatement1
            }
            module_info['instances'].append(instance_info)

        # Handling other declarations such as Input, Output, etc.
        elif isinstance(instance, pyverilog.vparser.ast.Decl):
            print(instance.list)
            for p in instance.list:
                if isinstance(p, pyverilog.vparser.ast.Input):
                    port_name = f'{int(str(p.width.msb)) - int(str(p.width.lsb)) + 1}-bit Input ' + p.name if p.width else "Input " + p.name # adds bit width for variable if it exists.
                    module_info['ports'].append(port_name)
                elif isinstance(p, pyverilog.vparser.ast.Output):
                    port_name = f'{int(str(p.width.msb)) - int(str(p.width.lsb)) + 1}-bit Output ' + p.name if p.width else "Output " + p.name
                    port_name = "Output " + p.name
                    module_info['ports'].append(port_name)
                elif isinstance(p, pyverilog.vparser.ast.Wire):
                    print(dir(p))
                    wire_name = f'{int(str(p.width.msb)) - int(str(p.width.lsb)) + 1}-bit Wire ' + p.name if p.width else "Wire " + p.name
                    module_info['ports'].append(wire_name)
                elif isinstance(p, pyverilog.vparser.ast.Reg):
                    reg_name = f'{int(str(p.width.msb)) - int(str(p.width.lsb)) + 1}-bit Reg ' + p.name if p.width else "Reg " + p.name
                    module_info['ports'].append(reg_name)
                elif isinstance(p, pyverilog.vparser.ast.Parameter):
                    param_name = f'{int(str(p.width.msb)) - int(str(p.width.lsb)) + 1}-bit Paramater ' + p.name if p.width else "Parameter " + p.name
                    if p.value.var:
                        param_name = param_name + f" (initialized to {(p.value.var)})"
                    module_info['ports'].append(param_name)
                else:
                    print(f"Error gathering info on Port {p.first.name}")
        elif isinstance(instance, pyverilog.vparser.ast.InstanceList):
            x = f'Module {instance.instances[0].module} instantiated as {instance.instances[0].name}'
            instance_info = {'Module Instantiations': x}
            module_info['instances'].append(instance_info)
            
        else:
            print("Not an assign, decl, if or always statement")
    
    # Append to the global module_details list
    module_details.append(module_info)
    output_module_details()

def output_module_details():
    result = []
    for module in module_details:
        module_info = {
            'module name': module['name'],
            'ports': module['ports'],
            'instances': []
        }

        # Iterate over the instances and add relevant statements
        for instance in module.get('instances', []):
            if 'Assign statement' in instance:
                statement = instance['Assign statement']  # Extract LHS name
                module_info['instances'].append({'Assign statement': statement})
            if 'Always senslist' in instance:
                senslist = instance['Always senslist']
                module_info['instances'].append({'Always senslist': senslist})
            if 'Always statement' in instance:
                astatement = instance['Always statement']
                module_info['instances'].append({'Always statement': astatement})
            if 'Variables initialized' in instance:
                statement = instance['Variables initialized']
                module_info['instances'].append({'Variables initialized': statement})
            if 'If statement' in instance:
                x = instance['If statement']
                module_info['instances'].append({'If statement': x})
            if 'Module Instantiations' in instance:
                x = instance['Module Instantiations']
                module_info['instances'].append({'Module Instantiation': x})
            if 'Case Statement' in instance:
                x = instance['Case Statement']
                module_info['instances'].append({'Case Statement': x})
        result.append(module_info)

    # Print the result to see the module details
    for module in result:
        # Print the module name with a newline after it
        print(f"Module name: {module['module name']}\n")
        
        # Print the module ports, joined by a comma and space
        ports = ', '.join(module['ports'])
        print(f"Module ports: {ports}\n")
        
        # Print the module instances, each on a new line
        print("Module instances:")
        for instance in module['instances']:
            for key, value in instance.items():
                print(f"    {key}: {value}")
        
        # Add a newline after the instances section
        print()


# make_file("""module slow_clock(Clk, Clk_Slow);
# parameter size = 100000000;  //added to be used by test bench 
# input x;
# output Clk_Slow;
# reg [31:0] counter_out;
# reg Clk_Slow;
# 	initial begin	//Note this will synthesize because we are using an FPGA and not making an IC
# 	counter_out<= 32'h00000000;
# 	Clk_Slow <=0;
# 	end
	
# //this always block runs on the fast 100MHz clock
# always @(*) begin
# 	counter_out<=    counter_out + 32'h00000001;
		
# 	if (counter_out  > size) 
# 		counter_out <= 32'h00000000;
# 		Clk_Slow <= !Clk_Slow;
# 	end

# endmodule

# """)

make_file("""
module Partial_Full_Adder (A,B,C,S,G,P);
    input A, B, C;
    output S,G,P;

  assign G = A & B;
  assign P = A ^ B;
  assign S = P ^ C;
 
  endmodule
 
  module CLA_logic(G, P, Cin, Carry, Cout);

input [3:0] G, P;
input Cin;
output [2:0] Carry;
output Cout;



  assign Carry[0] = G[0] | (P[0] & Cin);
  assign Carry[1] = G[1] | (P[1] & G[0]) | (P[1] & P[0] & Cin);
  assign Carry[2] = G[2] | (P[2] & G[1]) | (P[2] & P[1] & G[0]) | (P[2] & P[1] & P[0] & Cin);
  assign Cout = G[3] | (P[3] & G[2]) | (P[3] & P[2] & G[1]) | (P[3] & P[2] & P[1] & G[0])|(P[3] & P[2] & P[1] & P[0] & Cin);



endmodule

 
module CLA_4BIT(A,B,Cin,Sum,Cout);
input [3:0] A, B;
input Cin;
output [3:0] Sum;
output Cout;

wire [2:0] Carry;
wire [3:0] G,P;

 Partial_Full_Adder F0 (A[0], B[0], Cin, Sum[0], G[0], P[0]);
 Partial_Full_Adder F1 (A[1], B[1], Carry[0],Sum[1], G[1], P[1]);
 Partial_Full_Adder F2 (A[2], B[2], Carry[1],Sum[2], G[2], P[2]);
 Partial_Full_Adder F3 (A[3], B[3], Carry[2],Sum[3], G[3], P[3]);

  CLA_logic CLA_logic_inst (G, P, Cin, Carry, Cout);

 endmodule



""")

make_file("""module $D_FF(CLK, D, RST, Q, Q_NOT);
    input [3:0] CLK, D, RST;
    output reg Q, Q_NOT
    
    always@() begin
        if(RST) begin
            Q <= 1'b0
            Q_NOT <= 1'b1;
            end
        else begin
            Q <= D;
            Q_NOT <= !D;
            end
            end
endmodule""")
# make_file("""module counter(
#     input clk,
#     input reset,
#     output reg [3:0] count
# );
#     assign clk = count;
#     always @(clk) begin
#         if (reset)
#             count <= 4'b0000;
#         else
#             count <= 0;
#     end
# endmodule""")

# make_file("""module d_flip_flop (  
# input wire d,   
# input wire clk, 
# input wire reset, 
# output wire q);  
# always @() begin  
#  if (reset) begin // When 'reset' is active (1), asynchronously reset the flop.  
#   q <= 1'b0;  
#  end  
#  else begin // On the rising edge of the clock, store the value of 'd'. 
#   q <= d;  
#  end  
# end  
# endmodule""")
#make_file("module test(a, b, c, d); input a; output a, b;  assign a = b; endmodule") 
